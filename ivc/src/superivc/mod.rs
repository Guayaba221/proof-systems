//! This module contains an implementation of a variant of the non uniform IVC
//! circuit (NIVC) described in the paper
//! [SuperNova](https://eprint.iacr.org/2022/1758) to be used with the library
//! [folding](folding) of this monorepo. The curve will be supposed to be the
//! curve BN254. We will also suppose that the scalar multiplication can be
//! performed in two steps and that the NIVC circuit can simply perform a
//! foreign field elliptic curve addition.
//!
//! The circuit generalizes the IVC circuit described in the paper
//! [Nova](https://eprint.iacr.org/2021/370) to support non-uniform circuit by
//! adding a list of accumulators ("running instances") and by adding a
//! polynomial-time function φ that will be used to select the function to be
//! run in the circuit.
//!
//! The circuit can be used with the `o1vm` interpreter to run a
//! zero-knowledge virtual machine.
//! To encode the instructions of the virtual machine, the module will use the
//! encoding of the 32-bit instructions.
//! Suppose that there are N instructions, and their encodings is the 32bits
//! value `{x_1, x_1, ..., x_{N}}`.
//! The function φ will be the polynomial function that results of the
//! interpolation of the points `{(i, x_i)}` for `i = 1, ..., N`.
//! In the circuit, we will constrain the evaluation to be equal to zero to
//! encode the condition that `φ((z_i, w_i)) is in [1, ..., N]`, where `(z_i,,
//! w_i)` is the witness of the current instance.
//!
//! As the degree of this function is high (N - 1), we will encode the
//! evaluation of it to degree 2 constraints. The number of columns of the
//! circuit will restrict the number of instructions we can encode. However, as
//! described below, the number of columns will be significantly high to allow
//! the encoding of a large number of instructions, at least enough for a
//! reasonable virtual machine.
//!
//! The paper SuperNova encodes the instructions by polynomial-time function
//! `F_1`, ..., `F_N`. In this module, we want to allow a parallelisation of the
//! NIVC scheme. For that, we will first suppose that all the instructions of
//! the ISA the virtual machine encodes are given by the functions `F_1`, ...,
//! `F_M`.
//! We will suppose that the execution of the function `F_i` is simply given by
//! hashing the commitments to the columns generated by the execution of the
//! function `F_i`. It will give us the value `z_i`.
//!
//! We will also suppose that the polynomials representing the functions `F_i`
//! are over 435 variables. The number 435 is explained below.
// FIXME: maybe 435 will be different.
//!
//! The NIVC circuit described by the SuperNova paper needs to pass the public
//! IO to the next iteration. For that, we will use an instantiation of the
//! Poseidon hash function. For BN254, we decide to use the following parameters
//! to reach a security level of 128 bits: - The number of full rounds is 8.
//! - The number of partial rounds is 56.
//! - The number of state elements is 3.
//!
//! We decide to encode one full execution of the Poseidon hash function in one
//! row. It gives us a total of 435 columns and 192 public inputs to encode the
//! round constants.
//!
//! ## Layout of the circuit
//!
//! TODO
//! 1. Encode the polynomial φ.
//! 2. Check that the execution of the instruction is allowed by providing a
//! merkle path.
//! 3. Execute the function `F_(phi)`.
//! 4. Encode the verifier
//!   a. Compute FF EC addition.
//! 5. Compute a merkle root.
//!
//! ## Encode parallelisation
//!
//! The NIVC circuit as described in the SuperNova paper only allow one
//! instruction to be executed at the next step `i + 1`, as at step `i`, the
//! prover must execute the function `phi` to select the next instruction, and
//! compute the hash of the public IO to pass it to the next step. At the next
//! step, the NIVC circuit will check that the hash of the public IO is correct,
//! by recomputing the instruction to be run, and by checking the hash.
//!
//! To allow parallelisation (i.e. at step i + 1, the prover can run any
//! instruction in a set of instructions), we will instead compute a merkle
//! root at step i. At step i + 1, the prover will provide the path in the
//! merkle tree. This will allow to run any instruction in the set of the predefined
//! instructions. The overhead for the prover is to compute the merkle root at
//! the end of the step i.
pub mod columns;
pub mod constraints;
pub mod interpreter;
pub mod witness;
